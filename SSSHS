@@ -0,0 +1,1111 @@
# -*- coding: cp1250 -*-


from __future__ import division
import operator
#import matplotlib.pyplot as pyplot
from time import sleep, gmtime, strftime


#resources=15

sim_time = 45
callbacks = []
timer = 1
agents = []
agentNames = []
storages = []
storageNames = []
agentStorage = {}
allConsumption = []
allProduction = []
lowestCRLstorages = []

### STATISTICS ###

Overflow = 0
totalInterventions = 0 # Total number of system interventions. If the number is "fairly big", the system needs architectural changes.
firstIntervention = 0 # Time unit in which the first system intervention happened.
interventionTimes = [] # a list of time units in which interventions happened
economyRequests = 0 # A total number of economy requests
delayRequests = 0 # A total number of delay requests
restoreEconomyRequests = 0
advanceRequests = 0
giveRequests = 0
negotiationRequests = 0
UTalerts = 0 # upper threshold alerts
LTalerts = 0 # lower threshold alerts


###### SIMULATION CONTROL FUNCTION ###### 

def startSimulation():

    time = strftime("%d.%m.%Y %H:%M:%S", gmtime())

    print("\n\n\n*********** SIMULATION START ***********")
    print("****** TIME: %s *******" %time)

    for s in storages:
        storageNames.append(s.name)

    print ("****** Units in the system %s" %storageNames)


    i=0
    global timer
    while timer <= sim_time:

        print ("\n \n \n \n ---------------- Now is time unit: %d ---------------- " %timer)
        observer.storageReport()

        for s in storages:
            s.callAgents(timer)
            #print ("debugging info: calling all agents of the storage %s" %s)

        for a in agents:
            a.worked = "NO" # initially, no agents have been working yet

        if timer == sim_time:
            timer = 1
            observer.report()

        else:
            timer += 1
            #print ("debugging info: timer is now +1 = %d" %timer)
            #print ("debugging info: storages in list: %s" %storages)


####################### OBSERVER #######################

class observerAgent:

    def report (self):

        totalInterventions = economyRequests + delayRequests + restoreEconomyRequests + advanceRequests + giveRequests + negotiationRequests

        global Overflow
        for s in storages:
            Overflow += s.ResourceLoss

        print ("\n\n .... [ END OF SIMULATION ] ....")
        print ("\n\n ******* Number of system interventions: %d" %totalInterventions)
        print (" *********** First intervention happened at time: %d" %firstIntervention)

        print ("\n\n ******* Number of LT ALERTS: %d" %LTalerts)
        print ("\n *********** Number of DELAY  requests: %d" %delayRequests)
        print (" *********** Number of ECONOMY requests: %d" %economyRequests)
        print (" *********** Number of NEGOTIATION requests: %d" %negotiationRequests)

        print ("\n\n ******* Number of UT ALERTS: %d" %UTalerts)
        print ("\n *********** Number of RESTORE requests: %d" %restoreEconomyRequests)
        print (" *********** Number of ADVANCE requests: %d" %advanceRequests)
        print (" *********** Number of GIVE requests: %d" %giveRequests)
        print (" *********** Overflow of resources: %f" %Overflow)

        for s in storages:
            print ("\n\nINDIVIDUAL REPORT FOR STORAGE %s" %s.name)
            print (" - CRL: %d" %(s.currentResourceLevel))
            print (" - UT alerts: %d" %(s.myUTalerts))
            print (" - Advance reqs: %d" %(s.myAdvanceReqs))
            print (" - Resources lost: %f" %s.ResourceLoss)
            print (" - LT alerts: %d" %(s.myLTalerts))
            print (" - Economy reqs: %d" %(s.myEconomyReqs))
            print (" - Delay reqs: %d" %(s.myDelayReqs))
            print ("CRL HISTORY: %s" %s.CRLhistory)

        exit()

    def lowestCRLstoragesList (self): # a list of storages sorted by their current resource values

        lowestCRLstorages = sorted(storages, key=operator.attrgetter("currentResourceLevel"))
        return lowestCRLstorages


    def storageReport (self):

        for s in storages:

            total_production = s.currentProduction()
            total_consumption = s.currentReqs()

            print("\n Hello, I am STORAGE %s, regularly reporting:" %(s.name))
            print(" ---- My resource level: %f" %s.currentResourceLevel)
            s.CRLhistory.append(s.currentResourceLevel)
            print(" ---- My CRL history: %s" %s.CRLhistory)
            print(" ---- My max capacity: %d" %s.maxCapacity)
            print(" ---- My total production: %f" %total_production)
            print(" ---- My total consumption: %f" %total_consumption)
            #print(" ---- My agent codes: %s" %s.myAgents)
            #print(" ---- My agents: %s" %s.myAgentNames)
            print(" ---- My PRODUCERS: %s" %s.myProducers) # ...TO-DO
            print(" ---- My CONSUMERS: %s" %s.myConsumers) # ...TO-DO
            print(" ---- My agents working in economy mode: %s " %s.agentsInEconomy)


####################### CONSUMER / PRODUCER AGENT #######################
        

class agent:
    def __init__ (self, name, priority, capacity, workStart, workStop, belongsTo, eFactor):

        agents.append(self)
        agentStorage.update({self:belongsTo})

        self.name = name
        self.priority = priority
        self.capacity = capacity
        self.defaultCapacity = capacity
        self.workStart = workStart
        self.workStop = workStop
        self.originalWorkStart = workStart
        self.originalWorkStop = workStop
        self.mode = "normal"
        self.economyPossible = "YES"
        self.economyFactor = eFactor
        self.advancePossible = "YES"
        self.maxAdvance = 5
        self.delayPossible = "YES"
        self.maxDelay = 6
        self.currentDelay = 0
        self.worked = "NO" # if YES -> this agent has already worked in the current time unit; otherwise NO

        if sum(self.capacity) < 0:
            self.type = "CONSUMER"
        else:
            self.type = "PRODUCER"


    def working (self,timer):

        myStorage = agentStorage.get(self)
        
        if timer >= self.workStart and timer <= self.workStop:

            worked = "YES"

            print ("\n  > > > %s %s REPORTING \n ------ WORKING FROM %d AND %d" %(self.type, self.name, self.workStart, self.workStop))
           
            print (" ------ MY STORAGE: %s" %myStorage.name)

            if isinstance(self.capacity,list) == True: # temporary if/else, now the inputs are all in lists
                myStorage.currentResourceLevel += self.capacity[timer-1]
                print (" ------ MY CAPACITY: %f" %self.capacity[timer-1])
            else:
                myStorage.currentResourceLevel += self.capacity
                print (" ------ MY CAPACITY: %d" %self.capacity)

            print (" ------ NEW RESOURCE LEVEL for %s: %f" %(myStorage.name, myStorage.currentResourceLevel))
            #myStorage.CRLhistory.append(myStorage.currentResourceLevel)
            #print (" ------ RESOURCE LEVEL TRACKING: %s" %myStorage.CRLhistory)

            myStorage.currentReqs()
            myStorage.currentProduction()



    def changeMode (self, lowConsumer): # changing the mode to the ECONOMY mode

        print ("\n FUNCTION: changeMode\n")
        myStorage = agentStorage.get(self)

        if (self.mode == "economy") or (self.economyPossible == "NO"):
            print ("Agent %s already in ECONOMY mode or ECONOMY NOT POSSIBLE." %lowConsumer.name)
            return "nok"

        else:
           print ("\n -- OK! Agent %s now operating in economy mode." %lowConsumer.name)
           print(" -- OLD capacity value of the low consumer: %s." %self.capacity[timer-1])
           self.mode = "economy"
           myStorage.agentsInEconomy.append(self)
           self.economyCapacity = self.capacity[:]
           self.economyCapacity = [self.economyFactor*x for x in self.economyCapacity] # economy mode reduces consumption of resources by (economyFactor) percent
           self.capacity = self.economyCapacity

           print(" -- NEW capacity value of the low consumer: %s." %self.capacity[timer-1])
           print(" -- OLD CRL: %f." %myStorage.currentResourceLevel)
           difference = abs(self.defaultCapacity[timer-1]) - abs(self.economyCapacity[timer-1])
           myStorage.currentResourceLevel = myStorage.currentResourceLevel + difference
           print(" -- NEW CRL: %f." %myStorage.currentResourceLevel)
           #myStorage.CRLhistory.append(myStorage.currentResourceLevel)
           #print (" ------ RESOURCE LEVEL TRACKING: %s" %myStorage.CRLhistory)

           return "ok"


    def advance (self, lowConsumer): # funkcija za prijevremeno izvrsavanje rada potrosaca

        #self.advanceTime = advanceTime # Implement this LATER. For now, we are assuming that the new starting hour will be NOW (workStart=timer )

        if self.advancePossible == "NO":
            print ("Time advance operation not possible for agent %s. Sorry." %lowConsumer)
            return "nok"

        else:
            myStorage = agentStorage.get(self)
            tmpTime = self.workStop - self.workStart
            self.workStart = timer
            self.workStop = self.workStart + tmpTime
            myStorage.currentResourceLevel = myStorage.currentResourceLevel + self.capacity[timer-1] # explicitly change CRL, because the storage has already ran through the lists of its agents
            print ("\n * OK! NEW WORKTIME OF AGENT %s IS FROM %d TO %d." %(lowConsumer, self.workStart, self.workStop))
            return "ok"


   
    def delay (self, lowConsumer, delayTime):

        self.currentDelay = delayTime

        if self.delayPossible == "NO" or self.workStart == self.originalWorkStart + self.maxDelay:
            print ("\n * Sorry, delay not possible for unit: %s." %lowConsumer.name)
            return 0

        elif self.delayPossible == "YES" and (self.workStart + self.currentDelay) <= (self.maxDelay + self.originalWorkStart):
            print ("\n *OK! Operating time delay in FULL effect.")
            print (" * -- OLD WORKTIME OF AGENT %s IS FROM %d TO %d." %(lowConsumer, self.workStart, self.workStop))
            self.workStart = self.workStart + self.currentDelay
            self.workStop = self.workStop + self.currentDelay
            print (" * -- NEW WORKTIME OF AGENT %s IS FROM %d TO %d." %(lowConsumer, self.workStart, self.workStop))
            #self.currentDelay = self.currentDelay + delayTime
            return self.currentDelay

        elif self.delayPossible == "YES" and (self.workStart + self.currentDelay) > (self.maxDelay + self.originalWorkStart):
            print ("\n *NOT BAD! Operating time delay in PARTIAL effect.")
            print (" * -- OLD WORKTIME OF AGENT %s IS FROM %d TO %d." %(lowConsumer, self.workStart, self.workStop))
            self.workStart = self.workStart + (self.maxDelay + self.originalWorkStart - self.workStart)
            self.workStop = self.workStop + (self.maxDelay + self.originalWorkStop - self.workStop)
            print (" * -- NEW WORKTIME OF AGENT %s IS FROM %d TO %d." %(lowConsumer, self.workStart, self.workStop))
            #print (" * -- ORIGINAL WORKTIME OF AGENT %s IS FROM %d TO %d." %(lowConsumer, self.originalWorkStart, self.originalWorkStop))
            #self.currentDelay = self.currentDelay + delayTime
            return self.maxDelay




####################### STORAGE AGENT #######################
        

class StorageAgent:
    def __init__ (self, name, crl, maxCapacity, lowerThreshold, upperThreshold):

        storages.append(self)

        self.name = name
        self.maxCapacity = maxCapacity
        self.currentResourceLevel = crl
        self.lowerThreshold = lowerThreshold
        self.upperThreshold = upperThreshold
        self.currentOperatingMode = "Normal" #normal, economy, or delayed
        self.agentsByPriority = []
        self.currentlyWorkingAgents = []
        self.NonActiveAgents = []
        self.myAgents = []
        self.myAgentNames = []
        self.myProducers = [] # (names, not class references)
        self.myConsumers = [] # (names, not class references)
        self.myNeighbours = []
        self.agentsInEconomy = []
        self.ResourceLoss = 0
        self.myUTalerts = 0
        self.myLTalerts = 0
        self.myEconomyReqs = 0
        self.myDelayReqs = 0
        self.myAdvanceReqs = 0
        self.CRLhistory = []


    def callAgents(self, timer):

        self.myAgents = []
        self.myAgentNames = []
        self.myProducers = []
        self.myConsumers = []

        for key, value in agentStorage.items(): # who are my agents?
            if value == (self):
                self.myAgents.append(key)
                self.myAgentNames.append(key.name)

        for a in self.myAgents:
            if a.type == "CONSUMER":
                self.myConsumers.append(a.name)
            elif a.type == "PRODUCER":
              self.myProducers.append(a.name)

        for a in self.myAgents:
            a.working(timer)
            #print ("debugging info: calling working function of agent %s" %a)
            # TO CALL THRESHOLD ALERT AFTER EVERY CHANGE, OR ONLY AT THE END OF THE TIME UNIT?
            #self.thresholdAlert
        self.thresholdAlert


    def currentReqs(self): # adds up all the current resource requests of currently ACTIVE agents

        totalReqs = 0

        for c in self.myAgents:
            if timer >= c.workStart and timer <= c.workStop and c.capacity[timer-1] < 0:
                totalReqs = totalReqs + c.capacity[timer-1]

        return totalReqs


    def tomorrowRequests(self): # THIS IS WORK IN PROGRESS for future versions

        tomorrowReqs = 0

        for c in self.myAgents:
            if c.capacity[timer] < 0:
                tomorrowReqs = tomorrowReqs + abs(c.capacity[timer])

        return tomorrowReqs


    def currentProduction(self): # adds up all the current resource productions of currently ACTIVE agents

        totalProduction = 0

        for c in self.myAgents:
            if timer >= c.workStart and timer <= c.workStop and c.capacity[timer-1] > 0:
                totalProduction = totalProduction + c.capacity[timer-1]

        return totalProduction


    def tomorrowProduction(self):  # THIS IS WORK IN PROGRESS for future versions

        tomorrowProducs = 0

        for c in self.myAgents:
            if c.capacity[timer] > 0:
                tomorrowProducs = tomorrowProducs + c.capacity[timer]

        return tomorrowProducs


    @property

    def thresholdAlert(self):

        self.myAgents = [] # identify my agents
        for key, value in agentStorage.items():
            if value == (self):
                self.myAgents.append(key)


        # UPPER THRESHOLD ALERT --------------------------

        if self.currentResourceLevel >= self.upperThreshold: # and abs(self.currentReqs()) < self.currentProduction():

            print("\n ! ! ! ! UPPER THRESHOLD ALERT at storage %s! Calling agents to resume their default capacity.\n" %self.name )

            global UTalerts
            UTalerts += 1

            self.myUTalerts += 1

            global firstIntervention
            if firstIntervention == 0:
                firstIntervention=timer

            # RESTORING DEFAULT CAPACITY FROM ECONOMY CAPACITY

            j=0

            totalRequests = abs(self.currentReqs())
            totalProduction = self.currentProduction()

            for ag in reversed(self.agentsInEconomy): # reversed saved the day, otherwise not working
                #print(self.agentsInEconomy)
                #print(ag)

                if timer >= ag.workStart and timer <= ag.workStop:
                    print ("\n *OK! Agent %s restored from economy capacity: %f" %(ag.name, ag.capacity[timer-1]))

                    global restoreEconomyRequests
                    restoreEconomyRequests += 1

                    ag.capacity = ag.defaultCapacity
                    print (" * ---- Agent %s restored to default capacity: %f" %(ag.name, ag.capacity[timer-1]))
                    self.agentsInEconomy.remove(ag)
                    print (" * ---- Agents left in economy mode: %s" %self.agentsInEconomy)

                else:
                    print("Agent %s not currently working." %ag.name)

                if abs(self.currentReqs()) > self.currentProduction():
                    print(" * --- Capacity restoration successful. Resources saved by restoration. Exiting now.")
                    return
                #else:
                    #print(" * Restoration not complete. Calling next agent.")

            #print(" * Capacity restoration complete.")
            print(" * Capacity restoration complete, but NOT enough. Calling agents for advancing.")


            self.NonActiveAgents = []

            for agn in self.myAgents: # identify currently non-active consumers in order to activate them prematurely and raise the overall consumption
                if timer < agn.workStart and agn.capacity[timer-1] < 0:
                    self.NonActiveAgents.append(agn)

            # GIVE SURPLUS OF RESOURCES TO OTHER STORAGES:

            if len(self.NonActiveAgents) == 0:
                print ("\n NO MORE NON-ACTIVE CONSUMERS TO CALL. \n ")
                #amount = self.currentResourceLevel - self.upperThreshold + self.currentProduction() + self.currentReqs()
                amount = self.currentResourceLevel - self.upperThreshold + 1
                print("\n\n * %s now calling neighbours to GIVE freebies" %self.name)
                print (" * My CRL: %f" %self.currentResourceLevel)
                print (" * My UT value: %f" %self.upperThreshold)
                print (" * MY OFFER: %f" %(amount))

                global giveRequests
                giveRequests += 1

                self.giveResources(amount, 0)

            # REQUEST FOR ADVANCE:

            else:
                print(" * THESE ARE THE CURRENTLY NON-WORKING CONSUMERS: %s" %self.NonActiveAgents)
                self.agentsByPriority = sorted(self.NonActiveAgents, key=operator.attrgetter("priority"))
                print(" * THESE ARE THE CURRENTLY NON-WORKING, *SORTED* CONSUMERS: %s" %self.agentsByPriority)

                self.reqAdvance(0)

            #else:
                #print(" * Capacity restoration successful. Resources saved by restoration. Exiting now.")
                #return


        # LOWER THRESHOLD ALERT --------------------------

        if self.currentResourceLevel <= self.lowerThreshold: #and abs(self.currentReqs()) > self.currentProduction():
            print("\n ! ! ! ! %s LOWER THRESHOLD ALERT!" %self.name)
            print(" --- CRL: %f" %self.currentResourceLevel)
            print(" --- LT: %f" %self.lowerThreshold)
            print(" --- Calling agents to delay..\n")

            global LTalerts
            LTalerts += 1

            self.myLTalerts += 1

            global firstIntervention
            if firstIntervention == 0:
                firstIntervention=timer

            self.currentlyWorkingAgents = []

            for agn in self.myAgents:
                if timer >= agn.workStart and timer <= agn.workStop and agn.capacity[timer-1] < 0 and agn.worked == "NO": # agn.worked = "NO": the ones which haven't work yet in current time unit
                    self.currentlyWorkingAgents.append(agn)

            if len(self.currentlyWorkingAgents) == 0:
                print ("\n NO MORE ACTIVE CONSUMERS TO CALL. \n ")
                return ("nok")

            print("THESE ARE THE CURRENTLY WORKING CONSUMERS: %s" %self.currentlyWorkingAgents)

            self.agentsByPriority = sorted(self.currentlyWorkingAgents, key=operator.attrgetter("priority"))
            print("THESE ARE THE CURRENTLY WORKING, *SORTED* CONSUMERS: %s" %self.agentsByPriority)

            self.reqDelay(0)
            # self.reqEconomy(0)


    def reqEconomy(self, j):

        print ("\n FUNCTION: reqEconomy\n")

        global economyRequests
        economyRequests += 1

        self.myEconomyReqs += 1

        i=j
        answer = "nok"

        self.currentlyWorkingAgents = [] # reset the list, because Delay function maybe turned some agents off

        for agn in self.myAgents:
            if timer >= agn.workStart and timer <= agn.workStop and agn.capacity[timer-1] < 0:
                self.currentlyWorkingAgents.append(agn)

        print("THESE ARE THE CURRENTLY WORKING CONSUMERS: %s" %self.currentlyWorkingAgents)
        self.agentsByPriority = sorted(self.currentlyWorkingAgents, key=operator.attrgetter("priority"))
        print("THESE ARE THE CURRENTLY WORKING, *SORTED* CONSUMERS: %s" %self.agentsByPriority)


        while answer != "ok" and i != len(self.agentsByPriority):

            lowConsumer = self.agentsByPriority[i]
            print("\n This is the new candidate for economy mode:")
            print (lowConsumer.name)

            answer = lowConsumer.changeMode(lowConsumer) #call the changeMode method inside the consumer agent /request to go into economy mode

            i+=1
            #print (len(self.agentsByPriority))
            #print ("\n>>>>>>>>>> THIS IS THE VALUE OF INDEX i: %d" %i)
            #print (len(self.agentsByPriority))

        friend = i # remember who last responded with "ok"; later continue from the next one

        totalRequests = self.tomorrowRequests() # if some consumer responded with "OK", calculate if the new total values are still beneath the threshold
        totalProduction = self.tomorrowProduction()

        #if (totalProduction - totalRequests + self.currentResourceLevel) > self.lowerThreshold: # KITA. SAD PAK NE GLEDA kaj se desava danas, nego samo sutra, pa recimo iako nitko ne moze od potrosaca u economy, on prijavljuje SUCCESS.
        if self.currentResourceLevel > self.lowerThreshold:
            print ("\n ** NICE! Economy mode SAVED the day for the next time unit! ** ")
            return ("ok")

        #elif (self.currentResourceLevel - totalRequests) <= self.lowerThreshold and i == len(self.agentsByPriority): # if all the consumers are questioned and there is still not enough resources, than it is time to ping neighbours
        elif self.currentResourceLevel < self.lowerThreshold and i == len(self.agentsByPriority):
            print ("\n ** Calls for economy mode failed. Time to negotiate with neighbours. ** ")
            self.currentOperatingMode = "economy"

            # neededResources = self.lowerThreshold - self.currentResourceLevel + totalRequests + 1
            # neededResources = self.lowerThreshold - (self.currentResourceLevel+totalProduction-totalRequests) + 1 # trazi onoliko koliko ce trebati u SLJEDECOJ vremenskoj jedinici
            neededResources = self.lowerThreshold - self.currentResourceLevel + 1

            print (" ** %s asking for neighbour help, needed amount: %f \n \n" %(self.name, neededResources))

            negotiationResult = self.startNegotiation(neededResources, 0)

            if negotiationResult == "nn":
                #print ("debugging info: no neighbours, reqEconomy function")
                return ("ok")

        else:
            print ("\n ** Calling reqEconomy AGAIN. ** ")
            self.reqEconomy(friend) # if there is still not enough resources, but not all consumers were contacted, call the function recursively again



    def reqAdvance(self, j): # call function initially with j=0; recursively with the "friend" index

        global advanceRequests
        advanceRequests += 1

        self.myAdvanceReqs += 1

        i = j
        answer = "nok"

        #print ("\n>>>>>>>>>> THIS IS THE VALUE OF INDEX i: %d" %i)
        #print (len(self.agentsByPriority))

        while answer == "nok" and i != len(self.agentsByPriority):

            lowConsumer = self.agentsByPriority[i]
            answer = lowConsumer.advance(lowConsumer)
            i += 1


        friend = i
        totalRequests = abs(self.currentReqs()) # ponovno izracunavanje ukupnih zahtjeva - sada se potrosac "friend" dodaje zbroju jer mu se radno vrijeme pomaknulo unaprijed
        totalProduction = self.currentProduction()

        #if (self.currentResourceLevel + productionCapacity - totalRequests) < self.upperThreshold:
        if (totalProduction - totalRequests) <= 0: # mozda je dovoljno da trend bude negativan ili neutralan (0), mozda i ne - pratiti simulacije
            print (" ** RESOURCE LOSS PREVENTED BY ADVANCING! ** \n")
            return ("ok")

        elif i == len(self.agentsByPriority) and (self.currentResourceLevel + totalProduction - totalRequests) >= self.upperThreshold:
            print (" ** ... ! POSSIBLE LOSS OF RESOURCES ! ...")
            amount = self.currentResourceLevel - self.upperThreshold + self.currentProduction() + self.currentReqs() + 1
            print(" ** Now calling neighbours to GIVE freebies: %f" %amount)
            self.giveResources(amount, 0)

        else:
            print (" ** Calling advance AGAIN. ** ")
            self.reqAdvance(friend)



    def reqDelay(self, j):

        global delayRequests
        delayRequests += 1

        self.myDelayReqs += 1

        i = j
        answer = 0

        while answer == 0 and i != len(self.agentsByPriority):

            lowConsumer = self.agentsByPriority[i]
            answer = lowConsumer.delay(lowConsumer, timer+4) # "4" can be later replaced with a variable
            i += 1

        friend = i
        totalRequests = abs(self.currentReqs())
        totalProduction = self.currentProduction()

        if (totalProduction + self.currentResourceLevel - totalRequests) > self.lowerThreshold: # mozda je dovoljno da trend bude pozitivan ili neutralan (0), mozda i ne - pratiti simulacije
            print ("\n ** RESOURCE DEFICIT PREVENTED BY DELAYING! ** \n")
            return ("ok")

        elif (self.currentResourceLevel - totalRequests) <= self.lowerThreshold and i == len(self.agentsByPriority):
            print ("\n ** DELAYING FAILED. Calling consumers to economy modes...")
            self.reqEconomy(0)

        else:
            print ("\n ** Calling for delays AGAIN... ** ")
            self.reqDelay(friend)




    def startNegotiation(self, need, j):

        global negotiationRequests
        negotiationRequests += 1

        self.myNeighbours = storages[:]
        #print ("debugging info: BEFORE DELETING self.myNeighbours: %s" %self.myNeighbours)
        #print ("debugging info: BEFORE DELETING storages: %s" %storages)

        if not self.myNeighbours:
            print (" * Sorry, no neighbours detected. You are on your own pal.")
            if self.currentResourceLevel <= 0:
                print ("\n\n\n *********** SYSTEM NOT SELF-SUSTAINABLE in time: %d ***********" %timer)
                observer.report()
            return "nn"

        self.myNeighbours.remove(self)
        #print ("debugging info: AFTER DELETING self.myNeighbours: %s" %self.myNeighbours)
        #print ("debugging info: AFTER DELETING storages: %s" %storages)

        if not self.myNeighbours:
            print (" * Sorry, no neighbours detected. You are on your own pal.")
            if self.currentResourceLevel <= 0:
                print ("\n\n\n *********** SYSTEM NOT SELF-SUSTAINABLE in time: %d ***********" %timer)
                observer.report()
            return "nn"

        else:
            print ("\n ** My Neighbours (for negotiation): %s " %self.myNeighbours)

        i = j
        answer = 0
        #print ("DEBUGGING INFO, i VALUE: %d" %i)

        while answer == 0 and i != len(self.myNeighbours):
           closestNeighbour = self.myNeighbours[i]
           print("\n >> Pinging neighbour: %s" %closestNeighbour.name)
           answer = closestNeighbour.resourceNegotiation(need)
           i+=1

        friend = i
        self.currentResourceLevel = self.currentResourceLevel + answer
        totalRequests = self.currentReqs()
        #print("\nDebugging info i: %d" %i)
        #print("Debugging info CRL: %f" %self.currentResourceLevel)
        #print("Debugging info list length: %d" %len(self.myNeighbours))

        if self.currentResourceLevel <= 0 and i == len(self.myNeighbours): # if all the neighbours were contacted and there is a lack of resources, NOT SS
            print ("\n\n\n *********** SYSTEM NOT SELF-SUSTAINABLE in time: %d ***********" %timer)
            observer.report()

        elif self.currentResourceLevel > 0 and self.currentResourceLevel < self.lowerThreshold and i != len(self.myNeighbours): # more than 0, less than lower threshold
          neededResources = self.lowerThreshold - self.currentResourceLevel + 1
          print (" * Calling negotiations again ...")
          self.startNegotiation(neededResources, friend)

        elif self.currentResourceLevel >= self.lowerThreshold: # if above the lower threshold, end negotiations
          print ("\n * Negotiations successful. Exiting negotiations now.")

        else: # if there are still resources left, less than lower threshold, more than 0, all the neighbours contacted
            print ("\n * Negotiations NOT successful, but there are still some resources available.")



    def resourceNegotiation(self, need):
        toGive = need
        trend = self.currentProduction() - self.currentReqs()
        surplus = self.currentResourceLevel - self.lowerThreshold -1


        if trend >= 0 and surplus > 0 and surplus >= toGive: # ako je produkcija veca od potrosnje, ako ima viskova i ima ih vise nego trazi susjed, daj mu onoliko koliko trazi
            self.currentResourceLevel = self.currentResourceLevel - toGive # smanji svoje kolicine za toliko koliko se daje
            print ("\n * ALL wanted resources available. Transferring %s units.. have a good day!" %toGive)
            self.currentReqs()
            return toGive

        elif trend >= 0 and surplus > 0 and surplus < toGive:
            self.currentResourceLevel = self.currentResourceLevel - surplus
            print ("\n * SOME wanted resurces available. Transferring %s units.. have a good day!" %surplus)
            return surplus

        else:
            print("\n * Sorry, but I am in trouble myself. Good luck soldier!")
            return 0



    def giveResources(self, amount, j):

        global giveRequests
        giveRequests += 1

        #self.myNeighbours = storages[:]
        self.myNeighbours = observer.lowestCRLstoragesList()

        if not self.myNeighbours:
            print (" * Sorry, no neighbours detected. No-one go give freebies :(")
            return "nn"

        self.myNeighbours.remove(self)

        if not self.myNeighbours:
            print (" * Sorry, no neighbours detected. No-one go give freebies :(")
            return "nn"

        else:
            print (" * My Neighbours, sorted by CRL: %s " %self.myNeighbours)

        i = j
        answer = 0
        newAmount = 0

        while answer == 0 and i != len(self.myNeighbours):
           closestNeighbour = self.myNeighbours[i]
           print(" *\n Pinging neighbour: %s" %closestNeighbour.name)
           answer = closestNeighbour.acceptResources(amount)
           i+=1

        friend = i

        self.currentResourceLevel = self.currentResourceLevel - answer

        totalRequests = abs(self.currentReqs())
        totalProduction = self.currentProduction()

        if answer == amount:
            print ("\n ** Freebies given away, resources saved.")

        elif answer < amount and i != len(self.myNeighbours):
            newAmount = amount - answer
            print ("\n ** Offering freebies AGAIN, amount to give: %f ** " %newAmount)
            self.giveResources(newAmount, friend)

        else:
            #currentLoss = amount - answer
            currentLoss = self.currentResourceLevel - self.maxCapacity
            if currentLoss > 0:
                self.ResourceLoss = self.ResourceLoss + currentLoss
                self.currentResourceLevel = self.maxCapacity
                print ("\n ---- Lost resources just now: %f" %currentLoss)
            #self.currentResourceLevel = self.currentResourceLevel - currentLoss
            print ("\n ---- New Level for %s: %f" %(self.name, self.currentResourceLevel))
            print (" ---- Total resource loss so far for %s: %f" %(self.name, self.ResourceLoss))


    def acceptResources(self, amount):

        offer = amount
        totalRequests = self.currentReqs()
        totalProduction = self.currentProduction()

        #canTake = abs(self.upperThreshold - self.currentResourceLevel - totalProduction - totalRequests - 1) # OVO SE RACUNA NA KRAJU vrem.jedinice, pa su svi requestovi i production vec ukalkulirani u CRL
        canTake = abs(self.upperThreshold - self.currentResourceLevel - 1)
        print ("\n ** %s: My CRL: %f" %(self.name, self.currentResourceLevel))
        print (" ** %s: My UT value: %f" %(self.name, self.upperThreshold))
        print (" ** %s: My capacity value: %f" %(self.name, self.maxCapacity))
        print (" ** %s: My production: %f" %(self.name, totalProduction))
        print (" ** %s: My consumption: %f" %(self.name, totalRequests))
        #print("DEBUGGING INFO, OFFER: %f" %offer)

        if self.currentResourceLevel + totalProduction + totalRequests < self.upperThreshold:
            print (" ** %s: I can take this much: %f" %(self.name, canTake))

            if canTake <= offer:
                self.currentResourceLevel = self.currentResourceLevel + canTake
                print (" ** %s: I took a PARTIAL freeby: %f" %(self.name, canTake))
                print (" ** %s: My new CRL: %f" %(self.name, self.currentResourceLevel))
                return canTake
            else:
                self.currentResourceLevel = self.currentResourceLevel + offer
                print (" ** %s: I took a FULL freeby: %f" %(self.name, offer))
                print (" ** %s: My new CRL: %f" %(self.name, self.currentResourceLevel))
                return offer

        else:
            print (" * Sorry, don't need it.")
            return 0
